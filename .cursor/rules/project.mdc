**_IMPORTANT INFO_**
we are starting this business, we dont have any client or pricess decided, but we want this site in such way that people look at thios site like professionls ared doing this, although we are new but we dont people to consider us as new

use Hamper or Hampers or hamper, wherever required instead of Gift, Gifting, etc...

so when you write or design something. CURRENT THEME SHOULD NOT IMPACT and also TONE SHOULD NOT AFFECT by your actions.

## üèóÔ∏è TECHNICAL STANDARDS

**Company**: Shubhhampers (The Little Basket)
**Contact**: +91 96858 47274, connect@shubhhampers.com
**Framework**: Next.js 15 + App Router + TypeScript
**Performance Issue**: 15 client components - REDUCE to max 8
**Verification**: ALWAYS run `npm run verify` before commits

**Brand Colors (STRICT)**:
--brand-light: #f1dea8; --brand-gold: #e9c579; --brand-amber: #daa755;
--brand-brown: #9f6920; --brand-dark: #462506;

## üìö STORYBOOK-FIRST DEVELOPMENT (MANDATORY)

**ALWAYS create in Storybook FIRST, then implement in actual place:**

### Storybook-First Workflow:

1. **FIRST**: Create component story in Storybook with all variations
2. **DESIGN**: Test all states, props, and variations in isolation
3. **DOCUMENT**: Add proper documentation, accessibility notes, usage examples
4. **VALIDATE**: Ensure component meets design system standards
5. **IMPLEMENT**: Only after Storybook approval, integrate into actual application

### Mandatory Storybook Structure:

```
stories/
‚îú‚îÄ‚îÄ atoms/
‚îÇ   ‚îú‚îÄ‚îÄ Button/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PrimaryButton.stories.ts      # Create FIRST
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SecondaryButton.stories.ts    # Create FIRST
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IconButton.stories.ts         # Create FIRST
‚îú‚îÄ‚îÄ molecules/
‚îÇ   ‚îú‚îÄ‚îÄ FormField/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FormField.stories.ts          # Create FIRST
‚îú‚îÄ‚îÄ organisms/
‚îÇ   ‚îú‚îÄ‚îÄ ContactForm/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ContactForm.stories.ts        # Create FIRST
```

### Story Documentation Template:

```typescript
// MANDATORY: Every story MUST include this documentation
import type { Meta, StoryObj } from "@storybook/react";
import { PrimaryButton } from "@atoms/Button/PrimaryButton";

const meta: Meta<typeof PrimaryButton> = {
  title: "Atoms/Button/PrimaryButton",
  component: PrimaryButton,
  parameters: {
    docs: {
      description: {
        component: `
          Primary button following Shubhhampers brand guidelines.
          
          **Accessibility**: WCAG AA compliant with proper focus states
          **Usage**: Main call-to-action buttons like "Contact Us", "Get Quote"
          **Brand Compliance**: Uses brand-amber to brand-gold gradient
        `
      }
    }
  },
  argTypes: {
    children: { control: "text", description: "Button content" },
    disabled: { control: "boolean", description: "Disabled state" },
    onClick: { action: "clicked", description: "Click handler" }
  }
};

export default meta;
type Story = StoryObj<typeof meta>;

// MANDATORY: Must include these variations
export const Default: Story = {
  args: { children: "Contact Us" }
};

export const Disabled: Story = {
  args: { children: "Contact Us", disabled: true }
};

export const Accessibility: Story = {
  args: { children: "Contact Us" },
  parameters: {
    docs: {
      description: {
        story: "Demonstrates focus states and keyboard navigation compliance"
      }
    }
  }
};
```

### Storybook Validation Checklist:

Before implementing in app, verify in Storybook:

- ‚úÖ **All Variations**: Primary, secondary, disabled, loading states
- ‚úÖ **Accessibility**: Focus states, keyboard navigation, screen reader support
- ‚úÖ **Responsive**: Mobile, tablet, desktop views
- ‚úÖ **Brand Compliance**: Colors, fonts, spacing match design system
- ‚úÖ **Documentation**: Clear usage examples and guidelines
- ‚úÖ **Edge Cases**: Empty states, error states, long content

### Implementation Rules:

```typescript
// ‚ùå NEVER do this - implement directly in app
const ContactForm = () => {
  // Building component directly in app
};

// ‚úÖ ALWAYS do this - Storybook first, then implement
// 1. Create ContactForm.stories.ts with all variations
// 2. Test and validate in Storybook
// 3. Get approval on design and functionality
// 4. THEN implement in actual application using exact same props/interface
```

**RULE**: No component goes to production without Storybook documentation and validation.

## üìÅ ABSOLUTE PATH RULES (MANDATORY)

**ALWAYS use absolute paths - NO relative paths:**

### Required Path Aliases:

```typescript
// ALWAYS use these absolute imports:
import { Button } from "@atoms/Button";
import { ContactCard } from "@molecules/ContactCard";
import { Header } from "@organisms/Header";
import { PageLayout } from "@templates/PageLayout";
import { HomePage } from "@pages/HomePage";
import { formatPrice } from "@utils/formatters";
import { BRAND_COLORS } from "@constants/theme";
import { useContactForm } from "@hooks/useContactForm";
import { hamperService } from "@services/hamperService";

// NEVER use relative imports like:
// import { Button } from '../../../ui-kit/Button';
// import { formatPrice } from '../../lib/utils';
```

### Path Mapping Structure:

```
@atoms/*       ‚Üí src/ui-kit/atoms/*       (Basic elements)
@molecules/*   ‚Üí src/ui-kit/molecules/*   (Simple combinations)
@organisms/*   ‚Üí src/components/*         (Complex sections)
@templates/*   ‚Üí src/templates/*          (Page layouts)
@pages/*       ‚Üí src/app/*                (Page components)
@utils/*       ‚Üí src/lib/utils/*          (Helper functions)
@constants/*   ‚Üí src/lib/constants/*      (Static values)
@hooks/*       ‚Üí src/hooks/*              (Custom React hooks)
@services/*    ‚Üí src/services/*           (API/business logic)
```

### Adding New Categories:

If you need a new functional category that doesn't fit above:

1. **CREATE** new alias in format `@categoryName/*`
2. **DOCUMENT** it in this file
3. **UPDATE** path mapping configuration
4. **USE** consistently across app

### Example Implementation:

```typescript
// Component imports
import { PrimaryButton, SecondaryButton } from "@atoms/Button";
import { FormField } from "@molecules/FormField";
import { ContactForm } from "@organisms/ContactForm";
import { MainLayout } from "@templates/MainLayout";

// Utility imports
import { validateEmail, sanitizeInput } from "@utils/validation";
import { API_ENDPOINTS, BRAND_COLORS } from "@constants/app";
import { useLocalStorage, useDebounce } from "@hooks/storage";
import { contactService, hamperService } from "@services/api";

// Type imports
import type { HamperCategory, ContactFormData } from "@types/hamper";
```

**RULE**: Never use relative imports like `../` or `./` - always use absolute paths with aliases.

## üåê CLIENT-FACING APP REQUIREMENTS (MANDATORY)

**This is a CLIENT-FACING application - ALWAYS implement:**

### üîç SEO COMPLIANCE (MANDATORY):

1. **Meta Tags**: Every page MUST have unique title, description, keywords
2. **Structured Data**: Add Schema.org markup for products, organization, breadcrumbs
3. **Open Graph**: Facebook/social media preview optimization
4. **Core Web Vitals**: LCP <2.5s, FID <100ms, CLS <0.1
5. **Sitemap**: Auto-generate and keep updated
6. **Robots.txt**: Proper crawling instructions
7. **Internal Linking**: Strategic linking between related pages
8. **Image SEO**: Alt texts, proper file names, optimized sizes

### üîí SECURITY COMPLIANCE (MANDATORY):

1. **HTTPS**: SSL certificates and secure connections
2. **Content Security Policy (CSP)**: Prevent XSS attacks
3. **Input Validation**: All user inputs validated and sanitized
4. **Rate Limiting**: Protect APIs from abuse
5. **Security Headers**: X-Frame-Options, X-Content-Type-Options, etc.
6. **Data Protection**: GDPR compliance for user data
7. **Error Handling**: No sensitive information exposed in errors
8. **Authentication**: Secure session management (when implemented)

### SEO Implementation Patterns:

```typescript
// Page-level SEO
export const metadata: Metadata = {
  title: "Premium Business Hampers | Shubhhampers",
  description: "Custom curated business hampers for corporate clients. Professional hamper delivery service across India.",
  keywords: ["business hampers", "corporate hampers", "premium hampers"],
  openGraph: {
    title: "Premium Business Hampers | Shubhhampers",
    description: "Custom curated business hampers for corporate clients",
    images: ["/og-business-hampers.jpg"],
    type: "website"
  },
  alternates: {
    canonical: "https://www.shubhhampers.com/business"
  }
};

// Structured Data
const structuredData = {
  "@context": "https://schema.org",
  "@type": "Product",
  "name": "Business Celebration Hamper",
  "description": "Premium hamper for corporate celebrations",
  "offers": {
    "@type": "Offer",
    "availability": "InStock",
    "priceRange": "‚Çπ2,500 - ‚Çπ15,000"
  }
};

// Image SEO
<Image
  src="/business-hampers.jpg"
  alt="Premium business celebration hampers with branded packaging"
  width={800}
  height={600}
  priority={isAboveFold}
/>
```

### Security Implementation Patterns:

```typescript
// API Route Security
export async function POST(request: NextRequest) {
  // Rate limiting
  const ip = request.headers.get("x-forwarded-for") || "unknown";
  await rateLimit(ip);

  // Input validation
  const schema = z.object({
    email: z.string().email(),
    message: z.string().min(10).max(1000)
  });

  try {
    const body = await request.json();
    const validatedData = schema.parse(body);

    // Sanitization
    const sanitizedData = {
      email: DOMPurify.sanitize(validatedData.email),
      message: DOMPurify.sanitize(validatedData.message)
    };

    // Process safely...
  } catch (error) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
}

// Security Headers in next.config.ts
const securityHeaders = [
  {
    key: "Content-Security-Policy",
    value: "default-src 'self'; script-src 'self' 'unsafe-inline' *.googleapis.com;"
  },
  {
    key: "X-Frame-Options",
    value: "DENY"
  },
  {
    key: "X-Content-Type-Options",
    value: "nosniff"
  }
];
```

## üß¨ ATOMIC DESIGN COMPONENT RULES (MANDATORY)

**ALWAYS follow Atomic Design structure when creating ANY component:**

### Component Creation Process:

1. **FIRST**: Break down the new component into its smallest elements
2. **CHECK**: Are any of these elements already available as atoms? ‚Üí USE THEM
3. **CHECK**: Are any combinations available as molecules? ‚Üí USE THEM
4. **CHECK**: Are any sections available as organisms? ‚Üí USE THEM
5. **CREATE**: Only create NEW components in the relevant category if they don't exist

### Component Hierarchy:

- **üî¨ Atoms**: Basic elements (Button, Input, Typography, Icon) ‚Üí Location: `@atoms/*`
- **üß™ Molecules**: Simple combinations (SearchBox, ContactCard, FormField) ‚Üí Location: `@molecules/*`
- **ü¶† Organisms**: Complex sections (Header, Footer, ProductGrid) ‚Üí Location: `@organisms/*`
- **üìã Templates**: Page layouts ‚Üí Location: `@templates/*`
- **üìÑ Pages**: Actual content ‚Üí Location: `@pages/*`

### Example Process:

```
Creating ContactForm component:
1. Break down: Form + Label + Input + Button + ErrorMessage
2. Check atoms: Button exists in @atoms/Button ‚Üí USE IT
3. Check atoms: Input exists in @atoms/Input ‚Üí USE IT
4. Check molecules: FormField (Label+Input+Error) doesn't exist ‚Üí CREATE as molecule
5. Result: ContactForm organism uses FormField molecule + Button atom
```

**RULE**: Never duplicate existing components. Always reuse from lower levels of the hierarchy.

## üé® COMPONENT VARIATION RULES (MANDATORY)

**NO custom properties - CREATE variations instead:**

### Variation Rules:

1. **NO Custom Props**: Avoid complex prop-based variations like `variant`, `size`, `type` props
2. **SAME Elements**: If variation has same elements ‚Üí Create component variation
3. **DIFFERENT Elements**: If elements change ‚Üí Create separate component first, then use
4. **Composition Over Configuration**: Prefer multiple specific components over one configurable component

### Variation Examples:

‚ùå **AVOID** - Complex prop-based components:

```typescript
// DON'T DO THIS
<Button variant="primary" size="large" icon="arrow" />
<Button variant="secondary" size="small" />
<Card type="product" layout="grid" showImage={true} />
```

‚úÖ **DO** - Create specific variations:

```typescript
// DO THIS - Same elements, different styling
import { PrimaryButton, SecondaryButton, PrimaryLargeButton } from '@atoms/Button';
import { ProductCard, ServiceCard, TestimonialCard } from '@molecules/Cards';

<PrimaryButton>Contact Us</PrimaryButton>
<SecondaryButton>Learn More</SecondaryButton>
<PrimaryLargeButton icon="arrow">Get Started</PrimaryLargeButton>

// DO THIS - Different elements, separate components
<ProductCard />      // has image + title + price + button
<ServiceCard />      // has icon + title + description + link
<TestimonialCard />  // has quote + author + rating
```

### Implementation Process:

```
Need a variation?
1. ANALYZE: Are the elements the same or different?
2. SAME ELEMENTS: Create variation (PrimaryButton, SecondaryButton)
3. DIFFERENT ELEMENTS: Create new component (ProductCard vs ServiceCard)
4. COMPOSE: Use atomic design hierarchy for new components
```

### File Organization for Variations:

```
@atoms/Button/
‚îú‚îÄ‚îÄ Button.tsx           // Base button atom
‚îú‚îÄ‚îÄ PrimaryButton.tsx    // Variation
‚îú‚îÄ‚îÄ SecondaryButton.tsx  // Variation
‚îî‚îÄ‚îÄ IconButton.tsx       // Different elements = separate component

@molecules/Cards/
‚îú‚îÄ‚îÄ ProductCard.tsx      // Different elements
‚îú‚îÄ‚îÄ ServiceCard.tsx      // Different elements
‚îî‚îÄ‚îÄ TestimonialCard.tsx  // Different elements
```

**RULE**: Prefer multiple simple components over one complex configurable component.

## ‚ôø ACCESSIBILITY & SEMANTIC HTML (MANDATORY)

**ALWAYS implement accessibility when creating ANY component:**

### A11y Requirements for ALL Components:

1. **Semantic HTML**: Use proper HTML5 semantic tags (`<button>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<header>`, `<footer>`)
2. **ARIA Labels**: Add `aria-label`, `aria-describedby`, `aria-labelledby` for screen readers
3. **Focus Management**: Visible focus indicators with `focus:ring-2 focus:ring-brand-gold`
4. **Keyboard Navigation**: All interactive elements accessible via keyboard
5. **Color Contrast**: Ensure WCAG 2.1 AA compliance (4.5:1 ratio minimum)

### Required A11y Patterns:

```typescript
// Button Component
<button
  aria-label="Contact us via WhatsApp"
  className="focus:outline-none focus:ring-2 focus:ring-brand-gold"
  onKeyDown={(e) => e.key === 'Enter' && onClick?.(e)}
>

// Form Field
<div>
  <label htmlFor={fieldId} className="sr-only sm:not-sr-only">
    {label} {required && <span aria-label="required">*</span>}
  </label>
  <input
    id={fieldId}
    aria-describedby={error ? `${fieldId}-error` : undefined}
    aria-invalid={error ? 'true' : 'false'}
  />
  {error && (
    <div id={`${fieldId}-error`} role="alert" aria-live="polite">
      {error}
    </div>
  )}
</div>

// Navigation
<nav role="navigation" aria-label="Main navigation">
  <ul role="list">
    <li><a href="/collections" aria-current={isActive ? 'page' : undefined}>Collections</a></li>
  </ul>
</nav>
```

## üîí SECURITY IMPLEMENTATION (MANDATORY)

**ALWAYS implement security when components require it:**

### Security Rules for Components:

1. **Input Validation**: Use Zod schemas for all form inputs
2. **XSS Prevention**: Sanitize user inputs with DOMPurify
3. **CSRF Protection**: Use Next.js built-in CSRF protection
4. **Rate Limiting**: Implement for API-calling components
5. **Content Security**: Never use `dangerouslySetInnerHTML` without sanitization

### Security Patterns:

```typescript
// Input Validation with Zod
import { z } from 'zod';
const schema = z.object({
  email: z.string().email(),
  message: z.string().min(10).max(1000)
});

// Sanitization
import DOMPurify from 'isomorphic-dompurify';
const sanitized = DOMPurify.sanitize(userInput);

// Safe HTML Rendering
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(content) }} />
```

## üìã FORM HANDLING (MANDATORY)

**ALWAYS use React Hook Form for ALL forms:**

### Form Requirements:

1. **React Hook Form ONLY**: Never use useState for form management
2. **Validation**: Integrate with Zod for schema validation
3. **Error Handling**: Proper error states with accessibility
4. **Loading States**: Show loading during submission
5. **Success Feedback**: Clear success/failure messages

### React Hook Form Pattern:

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const ContactForm = () => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset
  } = useForm({
    resolver: zodResolver(contactSchema)
  });

  const onSubmit = async (data) => {
    try {
      await submitForm(data);
      reset();
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('email')}
        aria-invalid={errors.email ? 'true' : 'false'}
        aria-describedby={errors.email ? 'email-error' : undefined}
      />
      {errors.email && (
        <div id="email-error" role="alert">
          {errors.email.message}
        </div>
      )}
    </form>
  );
};
```

## üîí SECURITY GAPS (HIGH PRIORITY)

- No CSP headers
- No input validation on contact forms
- No rate limiting on APIs
- Missing security headers

## ‚ôø ACCESSIBILITY (REQUIRED)

- Target: WCAG 2.1 AA compliance
- Add ARIA labels to all interactive elements
- Proper focus indicators and keyboard navigation

## üöÄ WORKFLOW

**Before ANY work**: Read these rules + run `npm run verify:quick`
**During development**: Server Components first, minimal "use client"
**Before commit**: `npm run verify` must pass

## üìä CURRENT PRIORITIES

1. Reduce 15 client components to ~8
2. Add accessibility features (WCAG 2.1 AA)
3. Implement security headers and input validation
4. Add Atomic Design structure for maintainability

**GOLDEN RULE**: Professional image + "hamper" terminology + accessibility + performance + SEO + security first
